@context{domain:software_architecture, format:system_mapping, complexity:high, enforcement:mandatory}
@meta{estimated_tokens:850, critical_paths:4, validation_rules:12, size_constraints:enforced}

#ROOT
  ##philosophy{id:core_phil, type:foundational_principle, confidence:1.0, enforcement:mandatory}
    "Create structured, queryable application architecture maps"
    →size_constraint[max_300_lines, max_5_groups]
    →triggers_refactoring_when[exceeded]
    →computational_optimization:true

    ##constraint{id:size_limit, type:hard_rule, confidence:1.0, violation:immediate_action}
      "300 lines max, 5 feature groups max per domain"
      →enforcement:proactive_checking
      →action_required:CREATE_SUBDOMAIN_DIRECTORY
      →applies_to[domain_maps, feature_files]

    ##constraint{id:mega_feature, type:extraction_rule, confidence:1.0}
      "100+ lines per feature requires extraction"
      →action:EXTRACT_TO_FEATURE_FILE
      →timing:before_main_file_creation

  ##taxonomy{id:domain_classification, type:decision_framework, confidence:0.95}
    "Domain vs Dependency Classification Rules"

    ##domain_type{id:core_domains, type:category, confidence:1.0}
      "User-facing application areas with complete UI workflows"
      @examples{6}
        ##domain{id:chat_domain, type:core_domain, ui_section:true}
          "chat"
          →depends_on[memory_domain, file_manager_domain]
          →user_workflow:complete

        ##domain{id:health_domain, type:core_domain, ui_section:true}
          "health" 
          →depends_on[file_manager_domain]
          →integration_pattern:data_import

        ##domain{id:memory_domain, type:core_domain, special_case:true}
          "memory - AI system with own UI and complex logic"
          →depended_on_by[chat_domain, health_domain]
          →provides:ai_context

    ##domain_type{id:infrastructure_domains, type:category, confidence:1.0}
      "Cross-cutting technical concerns"
      →referenced_via:$ref_pattern
      →examples[routes, logging, infrastructure]

    ##anti_pattern{id:not_domains, type:classification_error, confidence:0.9}
      "Features mistakenly classified as domains"
      →should_be_features_within[parent_domain]
      @examples{4}
        "conversation-history → Feature within chat domain"
        "user-profile → Feature within settings domain"
        "metrics-dashboard → Feature within health domain"
        "attachments → Feature within chat domain"

  ##validation_framework{id:integration_validation, type:quality_gate, confidence:1.0, enforcement:mandatory}
    "Integration Status Validation Requirements"

    ##status{id:active_status, type:quality_level, confidence:1.0, evidence:required}
      "Implemented, tested, working end-to-end"
      →requires_evidence[component_api_tracing, endpoint_verification, ui_refresh_validation, integration_testing]
      →validation_chain:complete
      →cannot_mark_without:documented_proof

      ##evidence{id:component_tracing, type:validation_step, confidence:1.0}
        "Component-to-API call tracing documented"
        →traces[fetch_calls, query_keys, api_endpoints]
        →verifies:actual_vs_expected_paths
        →detects:bypassed_components

      ##evidence{id:cache_validation, type:validation_step, confidence:0.9}
        "Cache invalidation and UI refresh dependencies"
        →maps[invalidation_keys, refresh_components, cross_domain_effects]
        →validates:complete_refresh_chains
        →prevents:stale_ui_state

    ##status{id:partial_status, type:quality_level, confidence:0.8}
      "Implemented but with documented gaps"
      →requires:gap_documentation
      →allows:incomplete_functionality
      →blocks:full_deployment

    ##status{id:broken_status, type:quality_level, confidence:0.7}
      "Exists but fails during execution"
      →requires[failure_modes, root_cause_analysis]
      →execution_state:failing

  ##workflow{id:mapping_process, type:procedure, confidence:1.0, sequence:mandatory}
    "System Mapping Creation Workflow"

    ##step{id:initialize, type:action, order:1, confidence:1.0}
      "Initialize system maps directory structure"
      →creates[root_map, domain_directories]
      →establishes:foundational_context
      →next_step[domain_analysis]

    ##step{id:domain_analysis, type:action, order:2, confidence:0.9, critical:true}
      "Analyze and plan domain structure"
      →analyzes[entry_points, complexity_estimation, dependency_mapping]
      →triggers_size_check:before_creation
      →creates:domain_directory_structure
      →next_step[dependency_analysis]

    ##step{id:dependency_analysis, type:action, order:3, confidence:1.0, critical:true}
      "Comprehensive recursive dependency mapping"
      →starts_with:entry_points
      →follows:import_statements_meticulously  
      →continues_until:complete_mapping
      →maps:all_contributing_files
      →next_step[flow_tracing]

    ##step{id:flow_tracing, type:action, order:4, confidence:0.9, critical:true}
      "Complete user and system flow tracing"
      →traces[ui_to_api, api_to_database, cache_dependencies]
      →verifies:architectural_intent_vs_actual
      →identifies:bypassed_components
      →documents:integration_gaps
      →next_step[validation]

    ##step{id:validation, type:action, order:5, confidence:1.0, critical:true}
      "Comprehensive validation and documentation"
      →tests:integration_points
      →validates:cache_invalidation_chains
      →documents:known_issues
      →updates:integration_status
      →ensures:accuracy

  ##architecture_patterns{id:federated_structure, type:design_pattern, confidence:1.0}
    "Hybrid Federated Maps Architecture"

    ##component{id:root_map, type:manifest, confidence:1.0}
      "Single source of truth pointing to domain entry points"
      →contains[app_metadata, domain_registry, dependency_overview]
      →references:domain_maps

    ##component{id:domain_maps, type:feature_container, confidence:1.0}
      "User-facing application areas with complete functionality"
      →organized_by:domain_directories
      →size_limited[300_lines, 5_feature_groups]
      →contains:complete_user_workflows

    ##component{id:infrastructure_maps, type:reference_target, confidence:1.0}
      "Cross-cutting concerns referenced via $ref"
      →shared_across:multiple_domains
      →accessed_via:reference_pattern

    ##component{id:mega_feature_files, type:extracted_feature, confidence:0.9}
      "Large features extracted with $ref references"
      →triggered_by:100_plus_lines
      →maintains:parent_references
      →keeps:domain_context

@processing{
  critical_concepts:[size_constraints, integration_evidence, dependency_mapping, validation_workflow],
  enforcement_points:[size_estimation, status_validation, evidence_requirements],
  sequential_required:[initialize, domain_analysis, dependency_analysis, flow_tracing, validation],
  parallel_possible:[domain_directories, feature_extraction, cache_mapping],
  quality_gates:[size_check, evidence_validation, integration_testing]
}

@validation{
  mandatory_checks:[size_estimation_before_creation, evidence_for_active_status, complete_cache_chains],
  blocking_violations:[size_exceeded, active_without_evidence, incomplete_validation],
  refactoring_triggers:[300_line_exceeded, 5_group_exceeded, mega_feature_detected],
  compliance_requirements:[schema_adherence, reference_integrity, integration_accuracy]
}
@context{domain:system_mapping, target:ai_consumption, complexity:high, enforcement:strict}
@meta{tokens:850, critical_paths:5, validation_rules:12, processing_priority:1}

#ROOT{confidence:1.0, version:"2.0.0"}
  ##core_philosophy{id:mapping_foundation, type:foundational, confidence:1.0, @critical}
    "Create structured, queryable, unambiguous application architecture representation"
    @enforce:single_source_of_truth
    @optimize:computational_efficiency+llm_parsing+token_cost_minimization
    @target:federated_json_files

    ##design_principles{id:core_principles, confidence:1.0, @cluster}
      operational_efficiency_maximization,
      token_cost_minimization,
      analytical_accuracy_maximization,
      rigid_structure_adherence_for_llm_consumption
    @/cluster

  ##mandatory_checks{id:size_constraints, type:hard_rule, confidence:1.0, @blocking}
    "Proactive size validation before creation"
    @enforce:always_estimate_domain_size_before_creating_system_maps
    
    ##size_estimation{id:creation_limits, confidence:1.0, @blocking}
      "Max 300 lines, 5 feature groups per domain"
      @trigger:create_subdomain_directory[exceeded]
      @action:extract_to_feature_file[feature>100_lines]

  ##decision_framework{id:domain_classification, confidence:1.0, @critical}
    "Domain vs dependency classification rules"

    ##domains_definition{id:what_is_domain, confidence:1.0}
      "Top-level user-facing application areas"
      @examples{
        user_pages:["chat","health","devices","memory","file-manager","settings"],
        infrastructure:["routes","infrastructure"]
      }

    ##dependencies_definition{id:what_are_dependencies, confidence:1.0}
      "Other domains this domain relies on - NOT sub-features"
      @examples{
        "chat→memory[uses_memory_system]",
        "chat→file-manager[uses_file_attachments]",
        "health→file-manager[imports_health_files]"
      }

    ##anti_patterns{id:what_not_domains, confidence:1.0, @warning}
      "These should be features within domains, NOT separate domains"
      @examples{
        "conversation-history→feature_within_chat",
        "attachments→feature_within_chat",
        "user-profile→feature_within_settings",
        "metrics-dashboard→feature_within_health"
      }

  ##directory_structure{id:domain_organization, confidence:1.0, @sequential}
    "Domain-focused directory organization"
    @pattern:".system-maps/[domain-name]/[feature-group].map.json"
    @benefits{
      clear_domain_boundaries,
      focused_feature_organization,
      easy_navigation_maintenance,
      natural_team_ownership_alignment
    }

  ##file_structures{id:schema_definitions, confidence:1.0, @critical}
    "Rigid schema enforcement for computational efficiency"

    ##root_map{id:root_schema, confidence:1.0, @required}
      "Application manifest and domain directory"
      @required:[appName,version,lastUpdated,domains]
      @schema{
        appName:string,
        version:string,
        lastUpdated:iso8601_timestamp,
        domains:{
          "[domainName]":{
            description:string,
            path:string,
            dependencies:string_array
          }
        }
      }

    ##domain_map{id:domain_schema, confidence:1.0, @required}
      "Complete domain functionality mapping"
      @constraints{max_lines:300, max_feature_groups:5}
      @required:[tableOfContents,integrationStatus,lastUpdated,dependencies,featureGroups]
      @schema{
        tableOfContents:grouped_feature_index,
        integrationStatus:validation_evidence,
        featureGroups:detailed_feature_definitions,
        components:component_definitions,
        apiEndpoints:api_definitions,
        database:schema_definitions
      }

    ##feature_file{id:mega_feature_schema, confidence:1.0}
      "Extracted large feature definitions"
      @trigger:feature>100_lines
      @required:[_metadata,description,userFlow,systemFlow]
      @refs:parent_component_definitions

  ##integration_validation{id:evidence_framework, confidence:1.0, @critical}
    "Mandatory integration evidence requirements"

    ##status_levels{id:validation_states, confidence:1.0, @cluster}
      ##active{status:"implemented+tested+working", @requires:evidence}
        @validation{
          component_to_api_tracing,
          endpoint_verification,
          ui_refresh_dependency_validation,
          integration_testing_evidence,
          data_flow_verification,
          !architectural_bypasses
        }

      ##partial{status:"implemented+gaps", @requires:documented_gaps}
      ##planned{status:"designed+not_implemented", @requires:design_only}
      ##broken{status:"exists+execution_failure", @requires:failure_analysis}
    @/cluster

    ##evidence_requirements{id:validation_steps, confidence:1.0, @sequential}
      component_to_api_tracing,
      endpoint_verification,
      data_flow_verification,
      architectural_intent_validation,
      ui_refresh_validation,
      integration_testing_proof

  ##flow_patterns{id:tracing_methodology, confidence:1.0, @critical}
    "Standardized patterns for user/system flow documentation"
    @patterns{
      user_flow:"UI_interaction→API_call→database_operation→cache_update→UI_refresh",
      system_flow:"service_trigger→background_process→data_transformation→storage→notification",
      integration_flow:"external_api→validation→transformation→internal_storage→ui_update",
      streaming_flow:"user_input→go_ai_gateway→ai_provider→streaming_response→ui_display",
      error_flow:"failure_point→error_detection→fallback_strategy→user_notification→recovery_action"
    }
    @tracing_requirements{
      document_complete_paths:true,
      identify_bypass_routes:true,
      validate_architectural_compliance:true,
      map_error_boundaries:true
    }

  ##cache_dependencies{id:refresh_chain_mapping, confidence:1.0, @critical}
    "Complete cache invalidation and UI refresh chains with dependency patterns"
    @required:[invalidates,refreshesComponents,dependencyChain]
    @standard_patterns{
      query_invalidation:"query:endpoint_name",
      component_refresh:"ComponentName",
      cross_domain_cascade:"domain:affected_domain",
      dependency_chain:"parent→child→grandchild"
    }
    @examples{
      health_data_update:{
        invalidates:["query:healthData","query:healthMetrics"],
        refreshes:["HealthDashboard","MetricsCard","TrendChart"],
        triggers:["health-data-updated","metrics-recalculated"],
        dependencyChain:["health-data→metrics→dashboard→insights"]
      },
      memory_update:{
        invalidates:["query:memories","query:memoryInsights"],
        refreshes:["MemoryDisplay","ChatContext","RelationshipMap"],
        dependencyChain:["memory-entry→context→chat-enhancement→ui-display"]
      }
    }

  ##error_state_framework{id:failure_mode_documentation, confidence:1.0, @critical}
    "Comprehensive error state and failure boundary documentation"
    @required:[errorBoundaries,failureModes,recoveryStrategies,fallbackBehaviors]
    
    ##error_types{id:failure_categories, confidence:1.0, @cluster}
      network_failures:"API timeouts, connection errors, service unavailability",
      data_failures:"parsing errors, validation failures, corrupted data",
      system_failures:"memory exhaustion, disk space, service crashes",
      integration_failures:"external service errors, authentication failures, rate limits",
      user_input_failures:"invalid formats, missing required fields, constraint violations"
    @/cluster

    ##documentation_requirements{id:error_state_mapping, confidence:1.0}
      @for_each_feature{
        identify_failure_points:true,
        document_error_boundaries:true,
        specify_fallback_behaviors:true,
        define_recovery_strategies:true,
        map_user_impact:true
      }
      @examples{
        chat_message_failure:{
          failure_points:["AI service unavailable","network timeout","rate limit exceeded"],
          error_boundaries:["ChatInputArea","MessageDisplayArea"],
          fallback_behaviors:["queue message for retry","show error state","disable input"],
          recovery_strategies:["exponential backoff","service health check","user notification"],
          user_impact:"message sending temporarily disabled with clear feedback"
        }
      }

  ##workflow_steps{id:implementation_process, confidence:1.0, @sequential}
    ##step{id:initialize, order:1, @blocking}
      "Create .system-maps directory and root.map.json"

    ##step{id:domain_analysis, order:2, @critical}
      "Analyze and plan domain structure"
      @processing{
        identify_entry_points,
        estimate_complexity,
        create_domain_directories,
        plan_dependencies
      }

    ##step{id:recursive_dependency_analysis, order:3, @critical}
      "Comprehensive dependency mapping"
      @processing{
        start_with_entry_points,
        analyze_imports_meticulously,
        recursively_follow_dependencies,
        continue_until_complete_mapping
      }

    ##step{id:flow_tracing, order:4, @critical}
      "Complete user and system flow mapping with standardized patterns"
      @processing{
        apply_flow_patterns[user_flow,system_flow,integration_flow,streaming_flow,error_flow],
        trace_complete_request_paths,
        map_api_to_database_operations,
        verify_architectural_compliance,
        identify_service_bypasses,
        document_cache_dependency_chains,
        map_error_boundaries_and_fallbacks,
        validate_go_ai_gateway_usage,
        ensure_streaming_compliance
      }
      @architectural_validation{
        enforce_go_ai_gateway_for_streaming:true,
        detect_direct_ai_provider_calls:true,
        validate_service_utilization:true,
        document_bypass_justifications:required
      }

    ##step{id:validation_documentation, order:5, @blocking}
      "Comprehensive validation and evidence documentation"
      @processing{
        test_integration_points,
        validate_cache_invalidation,
        document_known_issues,
        update_integration_status
      }

@processing{
  critical_concepts:[domain_classification, size_constraints, integration_validation, cache_dependencies, flow_patterns, error_state_mapping],
  enforcement_points:[mandatory_size_estimation, evidence_requirements, schema_compliance, architectural_compliance],
  sequential_required:[initialize, domain_analysis, dependency_analysis, flow_tracing, validation],
  parallel_possible:[schema_validation, cache_mapping, integration_testing, error_boundary_mapping],
  quality_gates:[size_compliance, integration_evidence, cache_completeness, schema_validation, flow_pattern_compliance, error_state_coverage]
}

@validation{
  mandatory_checks:[size_estimation, integration_evidence, cache_dependencies, schema_compliance, flow_pattern_adherence, error_state_coverage],
  blocking_violations:[size_exceeded, missing_evidence, broken_references, invalid_schema, architectural_bypass_without_justification, missing_error_boundaries],
  compliance_requirements:[rigid_structure_adherence, computational_efficiency, llm_optimization, architectural_compliance, go_ai_gateway_usage],
  quality_standards:[no_active_without_evidence, complete_cache_chains, accurate_integration_status, comprehensive_flow_documentation, error_boundary_coverage],
  architectural_enforcement:[streaming_through_go_ai_gateway, no_direct_ai_provider_calls, service_utilization_validation, bypass_documentation_required]
}

@discovery_tools{
  recommended:[glob, search_file_content, read_file, read_many_files],
  analysis_patterns:[api_mapping, database_schema_analysis, route_handler_analysis],
  constraints:[domain_focus, integration_gap_documentation, critical_miss_modification]
}
