import type { AuditResult, ValidationIssue, AuditMetrics } from '../core/types.js';

export class MarkdownReporter {
  /**
   * Generate markdown report for audit results
   */
  generateReport(results: AuditResult[]): string {
    const lines: string[] = [];
    
    // Header
    lines.push('# System Map Auditor Report');
    lines.push('');
    lines.push(`Generated: ${new Date().toISOString()}`);
    lines.push('');

    // Summary
    const summary = this.calculateSummary(results);
    lines.push('## Summary');
    lines.push('');
    lines.push('| Metric | Value |');
    lines.push('|--------|-------|');
    lines.push(`| Features audited | ${summary.totalFeatures} |`);
    lines.push(`| Features passed | ${summary.passedFeatures} |`);
    lines.push(`| Total checks | ${summary.totalChecks} |`);
    lines.push(`| Execution time | ${summary.totalTime}ms |`);
    lines.push('');

    // Issues overview
    if (summary.totalIssues > 0) {
      lines.push('### Issues Found');
      lines.push('');
      lines.push('| Severity | Count |');
      lines.push('|----------|-------|');
      lines.push(`| Errors | ${summary.errorCount} |`);
      lines.push(`| Warnings | ${summary.warningCount} |`);
      lines.push(`| Info | ${summary.infoCount} |`);
      lines.push('');
    } else {
      lines.push('### âœ… No Issues Found');
      lines.push('');
      lines.push('All validations passed successfully!');
      lines.push('');
    }

    // Feature details
    lines.push('## Feature Results');
    lines.push('');

    for (const result of results) {
      lines.push(`### ${this.getStatusIcon(result.status)} ${result.feature}`);
      lines.push('');
      lines.push(`**Status:** ${result.status.toUpperCase()}`);
      lines.push(`**Checks:** ${result.metrics.totalChecks} (${result.metrics.executionTime}ms)`);
      lines.push('');

      if (result.issues.length > 0) {
        lines.push('#### Issues');
        lines.push('');
        
        const grouped = this.groupIssuesBySeverity(result.issues);
        
        for (const [severity, issues] of Object.entries(grouped)) {
          if (issues.length === 0) continue;
          
          lines.push(`##### ${this.getSeverityIcon(severity as any)} ${severity.toUpperCase()} (${issues.length})`);
          lines.push('');
          
          for (const issue of issues) {
            lines.push(`- **${issue.message}**`);
            lines.push(`  - Location: \`${issue.location}\``);
            if (issue.suggestion) {
              lines.push(`  - ðŸ’¡ Suggestion: ${issue.suggestion}`);
            }
            lines.push('');
          }
        }
      } else {
        lines.push('#### âœ… No Issues');
        lines.push('');
        lines.push('All validations passed for this feature.');
        lines.push('');
      }

      lines.push('---');
      lines.push('');
    }

    // Recommendations
    if (summary.totalIssues > 0) {
      const recommendations = this.generateRecommendations(results);
      lines.push('## Recommendations');
      lines.push('');
      
      for (const recommendation of recommendations) {
        lines.push(`- ${recommendation}`);
      }
      lines.push('');
    }

    // Footer
    lines.push('---');
    lines.push('');
    lines.push('*Report generated by System Map Auditor v1.0.0*');

    return lines.join('\n');
  }

  /**
   * Calculate summary statistics
   */
  private calculateSummary(results: AuditResult[]) {
    let totalChecks = 0;
    let totalIssues = 0;
    let errorCount = 0;
    let warningCount = 0;
    let infoCount = 0;
    let passedFeatures = 0;
    let totalTime = 0;

    for (const result of results) {
      totalChecks += result.metrics.totalChecks;
      totalIssues += result.issues.length;
      totalTime += result.metrics.executionTime;
      
      if (result.status === 'pass') {
        passedFeatures++;
      }

      for (const issue of result.issues) {
        switch (issue.severity) {
          case 'error':
            errorCount++;
            break;
          case 'warning':
            warningCount++;
            break;
          case 'info':
            infoCount++;
            break;
        }
      }
    }

    return {
      totalFeatures: results.length,
      passedFeatures,
      totalChecks,
      totalIssues,
      errorCount,
      warningCount,
      infoCount,
      totalTime
    };
  }

  /**
   * Get status icon for markdown
   */
  private getStatusIcon(status: string): string {
    switch (status) {
      case 'pass':
        return 'âœ…';
      case 'fail':
        return 'âŒ';
      case 'warning':
        return 'âš ï¸';
      default:
        return 'â“';
    }
  }

  /**
   * Get severity icon for markdown
   */
  private getSeverityIcon(severity: 'error' | 'warning' | 'info'): string {
    switch (severity) {
      case 'error':
        return 'ðŸ”´';
      case 'warning':
        return 'ðŸŸ¡';
      case 'info':
        return 'ðŸ”µ';
      default:
        return 'âšª';
    }
  }

  /**
   * Group issues by severity
   */
  private groupIssuesBySeverity(issues: ValidationIssue[]) {
    return issues.reduce((groups, issue) => {
      const severity = issue.severity;
      if (!groups[severity]) {
        groups[severity] = [];
      }
      groups[severity].push(issue);
      return groups;
    }, {} as Record<string, ValidationIssue[]>);
  }

  /**
   * Generate recommendations based on results
   */
  private generateRecommendations(results: AuditResult[]): string[] {
    const recommendations = new Set<string>();

    for (const result of results) {
      for (const issue of result.issues) {
        switch (issue.type) {
          case 'missing-component':
            recommendations.add('Review component paths in system maps');
            recommendations.add('Ensure all components exist in the codebase');
            break;
          case 'api-mismatch':
            recommendations.add('Verify API endpoint implementations');
            recommendations.add('Update system maps to match actual API structure');
            break;
          case 'circular-dependency':
            recommendations.add('Resolve circular dependencies in system maps');
            break;
          case 'invalid-reference':
            recommendations.add('Fix invalid references in system maps');
            break;
          case 'file-not-found':
            recommendations.add('Check file paths and ensure referenced files exist');
            break;
          case 'flow-inconsistency':
            recommendations.add('Align user flows with actual component capabilities');
            break;
        }
      }
    }

    return Array.from(recommendations);
  }

  /**
   * Generate issue table for markdown
   */
  generateIssueTable(issues: ValidationIssue[]): string {
    if (issues.length === 0) {
      return 'No issues found.';
    }

    const lines: string[] = [];
    lines.push('| Severity | Type | Message | Location |');
    lines.push('|----------|------|---------|----------|');

    for (const issue of issues) {
      const severity = this.getSeverityIcon(issue.severity);
      const message = issue.message.replace(/\|/g, '\\|'); // Escape pipes
      const location = issue.location.replace(/\|/g, '\\|');
      
      lines.push(`| ${severity} ${issue.severity} | ${issue.type} | ${message} | \`${location}\` |`);
    }

    return lines.join('\n');
  }

  /**
   * Generate metrics table
   */
  generateMetricsTable(metrics: AuditMetrics): string {
    const lines: string[] = [];
    lines.push('| Metric | Value |');
    lines.push('|--------|-------|');
    lines.push(`| Total checks | ${metrics.totalChecks} |`);
    lines.push(`| Passed checks | ${metrics.passedChecks} |`);
    lines.push(`| Warning checks | ${metrics.warningChecks} |`);
    lines.push(`| Failed checks | ${metrics.failedChecks} |`);
    lines.push(`| Execution time | ${metrics.executionTime}ms |`);

    return lines.join('\n');
  }

  /**
   * Generate feature status badge
   */
  generateStatusBadge(status: string): string {
    const color = status === 'pass' ? 'green' : status === 'warning' ? 'yellow' : 'red';
    return `![${status}](https://img.shields.io/badge/status-${status}-${color})`;
  }

  /**
   * Generate compact summary for README integration
   */
  generateCompactSummary(results: AuditResult[]): string {
    const summary = this.calculateSummary(results);
    const lines: string[] = [];

    lines.push('## System Map Audit Status');
    lines.push('');
    
    if (summary.totalIssues === 0) {
      lines.push('âœ… **All system maps validated successfully**');
    } else {
      lines.push(`âš ï¸ **${summary.totalIssues} issues found across ${summary.totalFeatures} features**`);
      
      if (summary.errorCount > 0) {
        lines.push(`- ðŸ”´ ${summary.errorCount} errors`);
      }
      if (summary.warningCount > 0) {
        lines.push(`- ðŸŸ¡ ${summary.warningCount} warnings`);
      }
      if (summary.infoCount > 0) {
        lines.push(`- ðŸ”µ ${summary.infoCount} info`);
      }
    }

    lines.push('');
    lines.push(`*Last updated: ${new Date().toISOString()}*`);

    return lines.join('\n');
  }
}