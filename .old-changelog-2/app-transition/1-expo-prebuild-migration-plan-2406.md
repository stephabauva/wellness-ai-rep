
# Expo Prebuild Migration Plan: Best of Both Worlds

## Mission
Migrate the wellness coach PWA to React Native using **Expo Prebuild** - combining Expo's excellent development experience with full native capabilities for health data access. This plan maintains **absolute stability** of the existing PWA while creating a premium native mobile experience.

## Strategic Approach: Expo Prebuild Advantage

### **Why Expo Prebuild Over Pure React Native:**
- **Expo Development Tools**: Keep the excellent Replit-compatible workflow
- **Native Code Access**: Full iOS/Android capabilities when needed
- **Gradual Native Adoption**: Start managed, add native features incrementally
- **Future-Proof**: Easy migration path for advanced native requirements
- **Replit Compatibility**: Perfect dual-port development (5000 + 19006)

## Architecture: Dual-Codebase During Transition

```
Current (Unchanged):
├── wellness-coach-pwa/          (continues on port 5000)
│   ├── client/                  (React PWA - unchanged)
│   ├── server/                  (Express API - shared)
│   └── Serves existing users

New (Parallel Development):
├── wellness-coach-native/       (new Expo project)
│   ├── src/
│   │   ├── screens/            (RN equivalents of PWA pages)
│   │   ├── components/         (RN UI components)
│   │   ├── services/           (90% reusable from PWA)
│   │   ├── hooks/              (95% reusable)
│   │   └── navigation/         (RN navigation)
│   ├── ios/                    (generated by prebuild)
│   ├── android/                (generated by prebuild)
│   ├── app.json                (Expo configuration)
│   └── Port 19006 → Expo web preview
```

## Phase 1: Expo Prebuild Project Setup (Days 1-2)

### 1.1 Initialize Expo Prebuild Project
```bash
# Create new React Native project with Expo prebuild
mkdir wellness-coach-native
cd wellness-coach-native

# Initialize with TypeScript template
npx create-expo-app --template blank-typescript

# Generate native iOS/Android projects
npx expo prebuild

# Install additional dependencies
npm install @react-navigation/native @react-navigation/bottom-tabs
npm install react-native-screens react-native-safe-area-context
npm install expo-health-kit expo-sensors expo-document-picker
npm install expo-camera expo-image-picker expo-notifications
```

### 1.2 Project Structure Setup
```
wellness-coach-native/
├── src/
│   ├── components/
│   │   ├── chat/
│   │   │   ├── ChatScreen.tsx
│   │   │   ├── MessageList.tsx
│   │   │   ├── ChatInput.tsx
│   │   │   └── StreamingMessage.tsx
│   │   ├── health/
│   │   │   ├── HealthScreen.tsx
│   │   │   ├── HealthDataSync.tsx
│   │   │   ├── NativeHealthIntegration.tsx
│   │   │   └── HealthMetrics.tsx
│   │   ├── files/
│   │   │   ├── FileScreen.tsx
│   │   │   ├── FileList.tsx
│   │   │   ├── FileUpload.tsx
│   │   │   └── CameraCapture.tsx
│   │   ├── settings/
│   │   │   ├── SettingsScreen.tsx
│   │   │   └── SettingsCard.tsx
│   │   └── ui/
│   │       ├── Button.tsx
│   │       ├── Card.tsx
│   │       ├── Input.tsx
│   │       └── LoadingSpinner.tsx
│   ├── navigation/
│   │   ├── AppNavigator.tsx
│   │   ├── TabNavigator.tsx
│   │   └── StackNavigator.tsx
│   ├── services/           (90% reusable from PWA)
│   │   ├── api-service.ts
│   │   ├── health-service.ts
│   │   ├── file-service.ts
│   │   └── native-health-service.ts
│   ├── hooks/              (95% reusable)
│   │   ├── useChatActions.ts
│   │   ├── useHealthData.ts
│   │   ├── useFileManager.ts
│   │   └── useNativeHealth.ts
│   ├── context/            (100% reusable)
│   │   └── AppContext.tsx
│   ├── types/              (100% reusable)
│   │   └── index.ts
│   └── utils/              (100% reusable)
│       └── helpers.ts
├── ios/                    (generated by expo prebuild)
├── android/                (generated by expo prebuild)
├── app.json
├── babel.config.js
├── metro.config.js
└── package.json
```

### 1.3 Expo Configuration (app.json)
```json
{
  "expo": {
    "name": "Wellness Coach",
    "slug": "wellness-coach-native",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.wellnesscoach.app",
      "infoPlist": {
        "NSHealthShareUsageDescription": "This app requires access to health data to provide personalized coaching.",
        "NSHealthUpdateUsageDescription": "This app can write health data to improve your wellness tracking."
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#FFFFFF"
      },
      "package": "com.wellnesscoach.app",
      "permissions": [
        "android.permission.RECORD_AUDIO",
        "android.permission.CAMERA",
        "android.permission.READ_EXTERNAL_STORAGE",
        "android.permission.WRITE_EXTERNAL_STORAGE"
      ]
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-health-kit",
      [
        "expo-camera",
        {
          "cameraPermission": "Allow $(PRODUCT_NAME) to access your camera to capture health-related photos."
        }
      ],
      [
        "expo-document-picker",
        {
          "iCloudContainerEnvironment": "Production"
        }
      ]
    ]
  }
}
```

## Phase 2: Service Layer Migration (Days 3-4)

### 2.1 API Service (90% Reusable)
```typescript
// src/services/api-service.ts
class ApiService {
  private baseUrl = 'http://0.0.0.0:5000/api'; // Same Express server
  
  async sendMessage(message: string, attachments?: any[]) {
    // Identical API call as PWA
    const response = await fetch(`${this.baseUrl}/messages`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message, attachments })
    });
    return response.json();
  }

  async uploadHealthData(data: any) {
    // Same endpoint as PWA
    const response = await fetch(`${this.baseUrl}/health-data`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    return response.json();
  }

  async uploadFile(file: any) {
    // Enhanced for React Native but same endpoint
    const formData = new FormData();
    formData.append('file', {
      uri: file.uri,
      type: file.type,
      name: file.name,
    } as any);

    const response = await fetch(`${this.baseUrl}/upload`, {
      method: 'POST',
      body: formData,
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    return response.json();
  }
}

export const apiService = new ApiService();
```

### 2.2 Native Health Service (New Capabilities)
```typescript
// src/services/native-health-service.ts
import * as HealthKit from 'expo-health-kit';
import { Platform } from 'react-native';
import { apiService } from './api-service';

export class NativeHealthService {
  async requestPermissions() {
    if (Platform.OS === 'ios') {
      return await HealthKit.requestPermissionsAsync([
        HealthKit.HealthKitPermissions.HeartRate,
        HealthKit.HealthKitPermissions.Steps,
        HealthKit.HealthKitPermissions.Weight,
        HealthKit.HealthKitPermissions.Height,
        HealthKit.HealthKitPermissions.SleepData,
      ]);
    }
    // Android health permissions would be handled here
    return { granted: false };
  }

  async syncHealthData() {
    try {
      if (Platform.OS === 'ios') {
        const healthData = await this.getHealthKitData();
        // Send to existing Express API (unchanged endpoint)
        return await apiService.uploadHealthData(healthData);
      }
      // Fallback to file upload method (PWA compatibility)
      return { success: false, fallbackAvailable: true };
    } catch (error) {
      console.error('Native health sync failed:', error);
      return { success: false, error: error.message };
    }
  }

  private async getHealthKitData() {
    const endDate = new Date();
    const startDate = new Date(endDate.getTime() - 30 * 24 * 60 * 60 * 1000); // 30 days

    const heartRateData = await HealthKit.getHealthRecordsAsync(
      HealthKit.HealthKitPermissions.HeartRate,
      { startDate, endDate }
    );

    const stepsData = await HealthKit.getHealthRecordsAsync(
      HealthKit.HealthKitPermissions.Steps,
      { startDate, endDate }
    );

    return {
      heartRate: heartRateData,
      steps: stepsData,
      collectedAt: new Date().toISOString(),
      source: 'native-ios-healthkit'
    };
  }

  async enableBackgroundSync() {
    // Subscribe to health data changes
    if (Platform.OS === 'ios') {
      HealthKit.subscribeToChanges(
        [HealthKit.HealthKitPermissions.HeartRate, HealthKit.HealthKitPermissions.Steps],
        () => {
          // Automatically sync when new data is available
          this.syncHealthData();
        }
      );
    }
  }
}

export const nativeHealthService = new NativeHealthService();
```

### 2.3 Hook Migration (95% Reusable)
```typescript
// src/hooks/useChatActions.ts (95% identical to PWA version)
import { useState, useCallback } from 'react';
import { apiService } from '../services/api-service';

export const useChatActions = () => {
  const [isLoading, setIsLoading] = useState(false);

  const sendMessage = useCallback(async (message: string, attachments?: any[]) => {
    setIsLoading(true);
    try {
      // Same logic as PWA, just different UI feedback
      const response = await apiService.sendMessage(message, attachments);
      return response;
    } catch (error) {
      console.error('Message send failed:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const sendStreamingMessage = useCallback(async (message: string) => {
    // Same streaming logic, adapted for React Native
    setIsLoading(true);
    try {
      const response = await fetch('http://0.0.0.0:5000/api/messages/stream', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message })
      });

      // Handle streaming response (same logic as PWA)
      const reader = response.body?.getReader();
      // ... streaming implementation identical to PWA
      
    } catch (error) {
      console.error('Streaming failed:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  return { sendMessage, sendStreamingMessage, isLoading };
};
```

## Phase 3: UI Component Development (Days 5-8)

### 3.1 Main Navigation Setup
```typescript
// src/navigation/AppNavigator.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Ionicons } from '@expo/vector-icons';

import ChatScreen from '../components/chat/ChatScreen';
import HealthScreen from '../components/health/HealthScreen';
import FileScreen from '../components/files/FileScreen';
import SettingsScreen from '../components/settings/SettingsScreen';

const Tab = createBottomTabNavigator();

export default function AppNavigator() {
  return (
    <NavigationContainer>
      <Tab.Navigator
        screenOptions={({ route }) => ({
          tabBarIcon: ({ focused, color, size }) => {
            let iconName: keyof typeof Ionicons.glyphMap;

            if (route.name === 'Chat') {
              iconName = focused ? 'chatbubbles' : 'chatbubbles-outline';
            } else if (route.name === 'Health') {
              iconName = focused ? 'fitness' : 'fitness-outline';
            } else if (route.name === 'Files') {
              iconName = focused ? 'documents' : 'documents-outline';
            } else if (route.name === 'Settings') {
              iconName = focused ? 'settings' : 'settings-outline';
            } else {
              iconName = 'ellipse';
            }

            return <Ionicons name={iconName} size={size} color={color} />;
          },
          tabBarActiveTintColor: '#007AFF',
          tabBarInactiveTintColor: 'gray',
          headerShown: false,
          tabBarStyle: {
            backgroundColor: '#1a1a1a',
            borderTopColor: '#333',
          },
        })}
      >
        <Tab.Screen name="Chat" component={ChatScreen} />
        <Tab.Screen name="Health" component={HealthScreen} />
        <Tab.Screen name="Files" component={FileScreen} />
        <Tab.Screen name="Settings" component={SettingsScreen} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}
```

### 3.2 Chat Screen (Adapted from PWA ChatSection)
```typescript
// src/components/chat/ChatScreen.tsx
import React, { useState, useEffect } from 'react';
import { 
  View, 
  StyleSheet, 
  KeyboardAvoidingView, 
  Platform,
  SafeAreaView 
} from 'react-native';
import MessageList from './MessageList';
import ChatInput from './ChatInput';
import { useChatActions } from '../../hooks/useChatActions';
import { useChatMessages } from '../../hooks/useChatMessages'; // Reused from PWA

export default function ChatScreen() {
  const { sendMessage, sendStreamingMessage, isLoading } = useChatActions();
  const { messages, addMessage, updateMessage } = useChatMessages(); // Same hook as PWA

  const handleSendMessage = async (message: string, attachments?: any[]) => {
    // Add user message immediately (optimistic update)
    const userMessage = { 
      id: Date.now().toString(), 
      text: message, 
      isUser: true, 
      attachments 
    };
    addMessage(userMessage);

    try {
      // Same business logic as PWA
      const response = await sendStreamingMessage(message);
      // Handle response...
    } catch (error) {
      console.error('Message failed:', error);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView 
        style={styles.container}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <MessageList messages={messages} />
        <ChatInput 
          onSendMessage={handleSendMessage}
          isLoading={isLoading}
        />
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#1a1a1a',
  },
});
```

### 3.3 Enhanced Health Screen with Native Capabilities
```typescript
// src/components/health/HealthScreen.tsx
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  Alert,
  Switch,
  TouchableOpacity,
  SafeAreaView 
} from 'react-native';
import { nativeHealthService } from '../../services/native-health-service';
import { useHealthData } from '../../hooks/useHealthData'; // Reused from PWA

export default function HealthScreen() {
  const [nativeHealthEnabled, setNativeHealthEnabled] = useState(false);
  const [hasPermissions, setHasPermissions] = useState(false);
  const [lastSync, setLastSync] = useState<Date | null>(null);
  const { healthData, refreshHealthData } = useHealthData(); // Same hook as PWA

  useEffect(() => {
    checkHealthPermissions();
  }, []);

  const checkHealthPermissions = async () => {
    try {
      const permissions = await nativeHealthService.requestPermissions();
      setHasPermissions(permissions.granted);
    } catch (error) {
      console.error('Permission check failed:', error);
    }
  };

  const enableNativeHealth = async () => {
    if (!hasPermissions) {
      const permissions = await nativeHealthService.requestPermissions();
      if (!permissions.granted) {
        Alert.alert(
          'Permissions Required',
          'Health data access is required for native sync functionality.'
        );
        return;
      }
      setHasPermissions(true);
    }

    setNativeHealthEnabled(true);
    await nativeHealthService.enableBackgroundSync();
    Alert.alert('Success', 'Native health sync enabled!');
  };

  const syncHealthData = async () => {
    try {
      const result = await nativeHealthService.syncHealthData();
      if (result.success) {
        setLastSync(new Date());
        await refreshHealthData(); // Refresh the existing PWA health data view
        Alert.alert('Success', 'Health data synced successfully!');
      } else if (result.fallbackAvailable) {
        Alert.alert(
          'Native Sync Unavailable',
          'Use the file upload method to import health data.',
          [
            { text: 'Cancel', style: 'cancel' },
            { text: 'Upload File', onPress: () => {/* Navigate to file upload */} }
          ]
        );
      }
    } catch (error) {
      Alert.alert('Sync Failed', error.message);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView style={styles.content}>
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Native Health Integration</Text>
          
          <View style={styles.settingRow}>
            <Text style={styles.settingLabel}>Enable Native Health Sync</Text>
            <Switch
              value={nativeHealthEnabled}
              onValueChange={enableNativeHealth}
              disabled={!hasPermissions}
            />
          </View>

          {nativeHealthEnabled && (
            <>
              <TouchableOpacity style={styles.syncButton} onPress={syncHealthData}>
                <Text style={styles.syncButtonText}>Sync Health Data Now</Text>
              </TouchableOpacity>

              {lastSync && (
                <Text style={styles.lastSyncText}>
                  Last sync: {lastSync.toLocaleString()}
                </Text>
              )}
            </>
          )}
        </View>

        {/* Existing health data display from PWA (reused components) */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Health Overview</Text>
          {/* Reuse existing health data visualization components */}
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#1a1a1a',
  },
  content: {
    flex: 1,
    padding: 16,
  },
  section: {
    marginBottom: 24,
    padding: 16,
    backgroundColor: '#2a2a2a',
    borderRadius: 8,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 16,
  },
  settingRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  settingLabel: {
    fontSize: 16,
    color: '#ffffff',
  },
  syncButton: {
    backgroundColor: '#007AFF',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 8,
  },
  syncButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  lastSyncText: {
    fontSize: 14,
    color: '#888888',
    marginTop: 8,
    textAlign: 'center',
  },
});
```

## Phase 4: Enhanced Native Features (Days 9-10)

### 4.1 Camera and File Integration
```typescript
// src/components/files/CameraCapture.tsx
import React, { useState } from 'react';
import { View, StyleSheet, Alert, TouchableOpacity, Text } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import * as DocumentPicker from 'expo-document-picker';
import { apiService } from '../../services/api-service';

export default function CameraCapture({ onFileSelected }: { onFileSelected: (file: any) => void }) {
  const [isUploading, setIsUploading] = useState(false);

  const takePhoto = async () => {
    const permissionResult = await ImagePicker.requestCameraPermissionsAsync();
    
    if (!permissionResult.granted) {
      Alert.alert('Permission Required', 'Camera access is needed to take photos.');
      return;
    }

    const result = await ImagePicker.launchCameraAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 0.8,
    });

    if (!result.canceled) {
      await uploadFile(result.assets[0]);
    }
  };

  const pickDocument = async () => {
    const result = await DocumentPicker.getDocumentAsync({
      type: '*/*',
      copyToCacheDirectory: true,
    });

    if (!result.canceled) {
      await uploadFile(result.assets[0]);
    }
  };

  const uploadFile = async (file: any) => {
    setIsUploading(true);
    try {
      // Use same upload API as PWA
      const result = await apiService.uploadFile(file);
      onFileSelected(result);
      Alert.alert('Success', 'File uploaded successfully!');
    } catch (error) {
      Alert.alert('Upload Failed', error.message);
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <View style={styles.container}>
      <TouchableOpacity style={styles.button} onPress={takePhoto} disabled={isUploading}>
        <Text style={styles.buttonText}>Take Photo</Text>
      </TouchableOpacity>

      <TouchableOpacity style={styles.button} onPress={pickDocument} disabled={isUploading}>
        <Text style={styles.buttonText}>Choose File</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    padding: 16,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 12,
    borderRadius: 8,
    minWidth: 120,
    alignItems: 'center',
  },
  buttonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
});
```

### 4.2 Push Notifications
```typescript
// src/services/notification-service.ts
import * as Notifications from 'expo-notifications';

export class NotificationService {
  async requestPermissions() {
    const { status } = await Notifications.requestPermissionsAsync();
    return status === 'granted';
  }

  async scheduleWellnessReminder(title: string, body: string, hours: number) {
    const hasPermission = await this.requestPermissions();
    if (!hasPermission) return false;

    await Notifications.scheduleNotificationAsync({
      content: {
        title,
        body,
        sound: 'default',
      },
      trigger: {
        seconds: hours * 3600,
      },
    });

    return true;
  }

  async scheduleHealthDataReminder() {
    return this.scheduleWellnessReminder(
      'Health Data Sync',
      'Time to sync your latest health data!',
      24 // Daily reminder
    );
  }
}

export const notificationService = new NotificationService();
```

## Phase 5: Replit Development Workflow (Days 11-12)

### 5.1 Development Commands
```bash
# Terminal 1: Keep existing PWA running (unchanged)
npm run dev  # Port 5000 - existing users

# Terminal 2: React Native development
cd wellness-coach-native
npx expo start  # Port 19006 - Expo dev server
```

### 5.2 Preview Strategy
```typescript
// Both apps run simultaneously:
// - PWA: http://0.0.0.0:5000 (existing users)
// - React Native Web: http://0.0.0.0:19006 (development preview)
// - Mobile Testing: Expo Go app + QR code from Replit terminal
```

### 5.3 Shared Backend Validation
```typescript
// Both PWA and React Native use identical endpoints:
// - POST /api/messages (chat)
// - POST /api/health-data (health sync)
// - POST /api/upload (file upload)
// - GET /api/settings (user settings)
```

## Phase 6: Testing & Quality Assurance (Days 13-14)

### 6.1 Cross-Platform Testing
```bash
# Test on multiple platforms
npx expo start
# Scan QR code with:
# - Expo Go (iOS)
# - Expo Go (Android)
# - Web browser (development)
```

### 6.2 Feature Parity Testing
```typescript
// Validate all PWA features work in React Native:
// ✅ Chat functionality with streaming
// ✅ Health data import (file + native)
// ✅ File management with camera
// ✅ Settings synchronization
// ✅ Memory system
// ✅ Performance benchmarks
```

## Phase 7: Build & Distribution (Days 15-16)

### 7.1 Generate Native Builds
```bash
# Install EAS CLI
npm install -g eas-cli

# Configure EAS
eas login
eas build:configure

# Build for iOS
eas build --platform ios

# Build for Android
eas build --platform android
```

### 7.2 App Store Preparation
```json
// App store assets needed:
{
  "appIcon": "1024x1024px",
  "screenshots": {
    "ios": ["iPhone", "iPad"],
    "android": ["Phone", "Tablet"]
  },
  "description": "AI-powered wellness coaching with native health data integration",
  "keywords": ["wellness", "health", "AI", "coaching", "fitness"]
}
```

## Migration Benefits & Code Reuse

| Component | PWA | React Native | Reuse % | Notes |
|-----------|-----|--------------|---------|-------|
| **Business Logic** | ✅ | ✅ | 95% | Hooks, services mostly identical |
| **API Calls** | ✅ | ✅ | 95% | Same endpoints, minor request changes |
| **State Management** | ✅ | ✅ | 100% | Context, hooks fully reusable |
| **Types** | ✅ | ✅ | 100% | TypeScript interfaces identical |
| **Utils** | ✅ | ✅ | 95% | Helper functions mostly reusable |
| **UI Components** | ✅ | ❌ | 0% | Complete rewrite for React Native |
| **Navigation** | ✅ | ❌ | 20% | Logic reusable, UI completely different |
| **Styling** | ✅ | ❌ | 15% | Colors/constants only |

**Overall Code Reuse: 75%**

## Native Capabilities Gained

### iOS HealthKit Integration
- Real-time heart rate monitoring
- Automatic step counting
- Sleep data collection
- Background health sync
- Push notifications for health goals

### Android Health Connect
- Google Fit integration
- Activity recognition
- Health data aggregation
- Background synchronization

### Enhanced File Management
- Native camera integration
- Document picker with cloud storage
- Photo editing capabilities
- Better file type support

## Risk Mitigation & Safety

### Zero Impact on PWA
- **PWA Unchanged**: Existing app continues on port 5000
- **Shared Backend**: Express API serves both apps
- **Independent Development**: No shared dependencies
- **Instant Rollback**: Can disable React Native app immediately

### Gradual User Migration
```typescript
// Feature flags for controlled rollout
const APP_CONFIG = {
  nativeAppAvailable: true,
  pwaStillSupported: true,
  migrationIncentives: ['native-health-sync', 'push-notifications']
};
```

## Performance Targets

- **App Launch**: < 2 seconds cold start
- **Navigation**: < 200ms screen transitions  
- **Health Sync**: < 5 seconds for 30 days of data
- **File Upload**: 2x faster than PWA with native picker
- **Memory Usage**: < 150MB baseline
- **Battery Impact**: < 5% daily drain

## Timeline Summary

```
Total Duration: 16 development days (3.2 weeks)

Week 1 (Days 1-5):
├── Expo prebuild setup
├── Service layer migration
└── Core navigation

Week 2 (Days 6-10):
├── UI component development
├── Native health integration
└── Enhanced file management

Week 3 (Days 11-16):
├── Replit workflow optimization
├── Testing & quality assurance
├── Build generation
└── App store preparation
```

## Recommendation: **PROCEED WITH EXPO PREBUILD**

This Expo Prebuild approach provides the optimal balance:

1. **Excellent Development Experience**: Keep Expo's great tooling
2. **Full Native Access**: Add native capabilities when needed
3. **75% Code Reuse**: Preserve most existing business logic
4. **Replit Compatible**: Perfect dual-port development workflow
5. **Future-Proof**: Easy path to advanced native features
6. **Risk-Free**: PWA remains untouched during migration

**Next Steps:**
1. Run the Expo test plan from `changelog/app-transition/expo-test.md`
2. Validate backend compatibility and mobile testing workflow  
3. Begin Phase 1 if test results are positive
4. Maintain PWA as production app during entire migration

This plan respects all I1/I2 constraints while delivering a premium native mobile experience that leverages your existing React expertise and preserves maximum code reuse.
